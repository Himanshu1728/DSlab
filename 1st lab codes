#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cout << "ENTER NUMBER OF STUDENT:";
    cin >> n;
    int arr[n][5],sum[n]={},avg[5]={};
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            cout << "ENTER MARKS OF " << i+1 << "th STUDENT IN "
                 << j+1 << "th SUBJECT:";
            cin >> arr[i][j];
            sum[i]+=arr[i][j];
            avg[j]+=arr[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            cout << "MARKS OF " << i+1 << "th STUDENT IN "
                 << j+1 << "th SUBJECT:";
            cout << arr[i][j]<<endl;
        }
        cout<<"SUM OF MARKS OF STUDENT "<<i+1<<"th IS:"<<sum[i]<<endl;
    }
    for(int j=0;j<5;j++){
        cout<<"AVERAGE OF SUBJECT "<<j+1<<"th IS:"<<avg[j]/n<<endl;
    }
}


// SECOND CODE of PALINFROME 
#include<bits/stdc++.h>
using namespace std;
bool ispalindrome(string s){
    int i=0;
    int j = s.size() -1;
    while(i<=j){
        if(s[i] != s[j]){
            cout << "Not Palindrome"<< endl;
            return false;
        }
        else{
            i++;
            j--;
        }
    }
    return true;

}
int main()
{
    string str = "nitip";
    cout << ispalindrome(str);
    return 0;
    
}

// THIRD CODE
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> arr;
    int capacity, choice;
    cout << "Enter the capacity of the array: ";
    cin >> capacity;
    arr.reserve(capacity);

    while (true) {
        cout << "\nChoose an option:\n";
        cout << "1. Insert at a specific location\n";
        cout << "2. Delete from a specific location\n";
        cout << "3. Display array\n";
        cout << "4. Quit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1: {
                if (arr.size() >= capacity) {
                    cout << "Array is full. Insertion not possible. (Overflow)\n";
                } else {
                    int value, position;
                    cout << "Enter the value to insert: ";
                    cin >> value;
                    cout << "Enter the position (0-based index) to insert: ";
                    cin >> position;

                    if (position < 0 || position > arr.size()) {
                        cout << "Invalid position. Please enter a valid index.\n";
                    } else {
                        arr.insert(arr.begin() + position, value);
                        cout << "Value inserted successfully.\n";
                    }
                }
                break;
            }

            case 2: {
                if (arr.empty()) {
                    cout << "Array is empty. Deletion not possible. (Underflow)\n";
                } else {
                    int position;
                    cout << "Enter the position (0-based index) to delete: ";
                    cin >> position;

                    if (position < 0 || position >= arr.size()) {
                        cout << "Invalid position. Please enter a valid index.\n";
                    } else {
                        arr.erase(arr.begin() + position);
                        cout << "Value deleted successfully.\n";
                    }
                }
                break;
            }

            case 3: {
                cout << "Array elements: ";
                for (int i = 0; i < arr.size(); i++) {
                    cout << arr[i] << " ";
                }
                cout << endl;
                break;
            }

            case 4:
                cout << "Exiting the program.\n";
                return 0;

            default:
                cout << "Invalid choice. Please select a valid option.\n";
        }
    }

    return 0;

// FOURTH CODE

int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Return the index of the target element if found
        }
    }
    return -1; // Return -1 to indicate that the target element was not found
}
// FIFTH CODE

int binarySearch(int arr[], int left, int right, int target) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        // If the target is found at the middle of the array, return its index
        if (arr[mid] == target)
            return mid;

        // If the target is in the left half of the array
        if (arr[mid] > target)
            right = mid - 1;

        // If the target is in the right half of the array
        else
            left = mid + 1;
    }

    // If the target is not found in the array, return -1
    return -1;
}

// SIXTH CODE

#include <iostream>

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        // Move elements of arr[0..i-1] that are greater than the key to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = key;
    }
}

// seventh code
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j + 1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// EIGHT CODE
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap the minimum element with the first element of the unsorted part
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}


// NINTH CODE

int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Choose the last element as the pivot
    int i = (low - 1); // Index of the smaller element

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Swap arr[i] and arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    // Swap arr[i + 1] and arr[high] to place the pivot in its correct position
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return (i + 1);
}

// Function to perform the quick sort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Partition the array and get the index of the pivot element
        int pivotIndex = partition(arr, low, high);

        // Recursively sort elements before and after the pivot
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

// TENTH CODE
void merge(int arr[], int left, int middle, int right) {
    int n1 = middle - left + 1;
    int n2 = right - middle;

    // Create temporary arrays
    int L[n1];
    int R[n2];

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[middle + 1 + j];

    // Merge the temp arrays back into arr[left..right]
    int i = 0; 
    int j = 0; 
    int k = left; 

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}


void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // Find the middle point
        int middle = left + (right - left) / 2;

        // Recursively sort the first and second halves
        mergeSort(arr, left, middle);
        mergeSort(arr, middle + 1, right);

        // Merge the sorted halves
        merge(arr, left, middle, right);
    }
}
// 11TH CODE

void heapify(int arr[], int n, int i) {
    int largest = i;  // Initialize the largest as the root
    int left = 2 * i + 1;  // Left child
    int right = 2 * i + 2;  // Right child

    // If the left child is larger than the root
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // If the right child is larger than the largest so far
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // If the largest is not the root
    if (largest != i) {
        std::swap(arr[i], arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Function to perform heap sort
void heapSort(int arr[], int n) {
    // Build a max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Extract elements one by one from the heap
    for (int i = n - 1; i > 0; i--) {
        std::swap(arr[0], arr[i]);  // Move the current root to the end
        heapify(arr, i, 0);  // Call max heapify on the reduced heap
    }
}








